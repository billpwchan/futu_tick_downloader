#!/usr/bin/env bash
set -euo pipefail

SERVICE_NAME="${SERVICE_NAME:-hk-tick-collector}"
DATA_ROOT="${DATA_ROOT:-/data/sqlite/HK}"
DAY_DEFAULT="$(TZ=Asia/Hong_Kong date +%Y%m%d)"

usage() {
  cat <<'USAGE'
hk-tickctl - HK Tick Collector 維運工具

用法:
  hk-tickctl status [--since "<time>"]
  hk-tickctl logs [--ops] [--since "<time>"] [--no-follow]
  hk-tickctl doctor [--since "<time>"]
  hk-tickctl db stats [--db <path>] [--day YYYYMMDD]
  hk-tickctl db symbols [--db <path>] [--day YYYYMMDD] [--minutes N]
  hk-tickctl db symbol <SYMBOL> [--db <path>] [--day YYYYMMDD] [--last N]
  hk-tickctl export [--db <path>] [--day YYYYMMDD] [--out <tar.gz>]
  hk-tickctl tg test [--token <token>] [--chat-id <chat_id>] [--thread-id <id>] [--text <msg>]

範例:
  hk-tickctl status
  hk-tickctl logs --ops --since "20 minutes ago"
  hk-tickctl db stats --day 20260213
  hk-tickctl export --day 20260213 --out /tmp/hk-20260213.tar.gz
  hk-tickctl tg test
USAGE
}

fail() {
  echo "[失敗] $*" >&2
  exit 1
}

info() {
  echo "[資訊] $*"
}

ok() {
  echo "[完成] $*"
}

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    fail "找不到命令: $1"
  fi
}

db_path_from_args() {
  local db_path="${1:-}"
  local day="${2:-$DAY_DEFAULT}"
  if [[ -n "${db_path}" ]]; then
    printf '%s\n' "${db_path}"
    return
  fi
  printf '%s/%s.db\n' "${DATA_ROOT}" "${day}"
}

file_size_bytes() {
  local path="$1"
  if [[ ! -f "${path}" ]]; then
    printf '0\n'
    return
  fi
  if stat -f%z "${path}" >/dev/null 2>&1; then
    stat -f%z "${path}"
    return
  fi
  stat -c%s "${path}"
}

sha256_file() {
  local path="$1"
  if command -v shasum >/dev/null 2>&1; then
    shasum -a 256 "${path}" | awk '{print $1}'
    return
  fi
  if command -v sha256sum >/dev/null 2>&1; then
    sha256sum "${path}" | awk '{print $1}'
    return
  fi
  fail "缺少 shasum/sha256sum，無法計算校驗碼"
}

run_logs() {
  local ops="0"
  local since="15 minutes ago"
  local follow="1"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --ops)
        ops="1"
        shift
        ;;
      --since)
        since="${2:-}"
        shift 2
        ;;
      --no-follow)
        follow="0"
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        fail "未知參數: $1"
        ;;
    esac
  done

  require_cmd journalctl
  require_cmd grep

  local pattern
  if [[ "${ops}" == "1" ]]; then
    pattern="health|health_symbols_rollup|persist_summary|WATCHDOG|ERROR|Traceback|telegram_|sqlite_busy|poll_stats|persist_ticks"
  else
    pattern="health|persist_summary|WATCHDOG|ERROR|Traceback|telegram_send_failed|telegram_alert_suppressed"
  fi

  info "服務=${SERVICE_NAME} since=${since} ops=${ops}"
  if [[ "${follow}" == "1" ]]; then
    journalctl -u "${SERVICE_NAME}" --since "${since}" -f --no-pager \
      | grep -E --line-buffered "${pattern}" || true
  else
    journalctl -u "${SERVICE_NAME}" --since "${since}" --no-pager \
      | grep -E "${pattern}" || true
  fi
}

run_status() {
  local since="20 minutes ago"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --since)
        since="${2:-}"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        fail "未知參數: $1"
        ;;
    esac
  done

  require_cmd systemctl
  require_cmd journalctl
  require_cmd grep

  local service_status
  service_status="$(systemctl is-active "${SERVICE_NAME}" 2>/dev/null || true)"
  [[ -n "${service_status}" ]] || service_status="unknown"

  local opend_status
  opend_status="$(systemctl is-active futu-opend 2>/dev/null || true)"
  [[ -n "${opend_status}" ]] || opend_status="unknown"

  local logs
  logs="$(journalctl -u "${SERVICE_NAME}" --since "${since}" --no-pager 2>/dev/null || true)"
  local health_line
  health_line="$(printf '%s\n' "${logs}" | grep -E "health sid=" | tail -n 1 || true)"
  local alert_line
  alert_line="$(printf '%s\n' "${logs}" | grep -E "severity=(WARN|ALERT)|WATCHDOG persistent_stall|telegram_send_failed|alert_event code=" | tail -n 1 || true)"

  echo "=== HK Tick 狀態 ==="
  echo "collector=${service_status} opend=${opend_status} time_window=${since}"

  if [[ -n "${health_line}" ]]; then
    echo "[健康] ${health_line}"
  else
    echo "[健康] 選定時間內沒有 health 訊息"
  fi

  if [[ -n "${alert_line}" ]]; then
    echo "[告警] ${alert_line}"
  else
    echo "[告警] 選定時間內無 WARN/ALERT/WATCHDOG"
  fi
}

run_db_stats() {
  local db_path=""
  local day="${DAY_DEFAULT}"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --db)
        db_path="${2:-}"
        shift 2
        ;;
      --day)
        day="${2:-}"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        fail "未知參數: $1"
        ;;
    esac
  done

  require_cmd sqlite3
  local db
  db="$(db_path_from_args "${db_path}" "${day}")"
  [[ -f "${db}" ]] || fail "找不到 DB: ${db}"

  local rows max_ts max_ts_utc drift index_count page_bytes
  IFS='|' read -r rows max_ts max_ts_utc drift index_count page_bytes < <(
    sqlite3 -separator '|' "file:${db}?mode=ro" "
SELECT
  COUNT(*) AS rows,
  IFNULL(MAX(ts_ms), 0) AS max_ts_ms,
  IFNULL(datetime(MAX(ts_ms)/1000,'unixepoch'),'n/a') AS max_ts_utc,
  IFNULL(ROUND(strftime('%s','now') - MAX(ts_ms)/1000.0, 3), 0) AS drift_sec,
  (SELECT COUNT(*) FROM sqlite_master WHERE type='index' AND tbl_name='ticks') AS index_count,
  (SELECT page_count * page_size FROM pragma_page_count(), pragma_page_size()) AS approx_bytes
FROM ticks;
"
  )

  local db_size wal_size shm_size
  db_size="$(file_size_bytes "${db}")"
  wal_size="$(file_size_bytes "${db}-wal")"
  shm_size="$(file_size_bytes "${db}-shm")"

  echo "=== DB 統計 ==="
  echo "db=${db}"
  echo "rows=${rows}"
  echo "max_ts_ms=${max_ts}"
  echo "max_ts_utc=${max_ts_utc}"
  echo "drift_sec=${drift}"
  echo "indices=${index_count}"
  echo "approx_bytes_sqlite=${page_bytes}"
  echo "file_bytes_db=${db_size}"
  echo "file_bytes_wal=${wal_size}"
  echo "file_bytes_shm=${shm_size}"
}

run_db_symbols() {
  local db_path=""
  local day="${DAY_DEFAULT}"
  local minutes="10"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --db)
        db_path="${2:-}"
        shift 2
        ;;
      --day)
        day="${2:-}"
        shift 2
        ;;
      --minutes)
        minutes="${2:-}"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        fail "未知參數: $1"
        ;;
    esac
  done

  require_cmd sqlite3
  local db
  db="$(db_path_from_args "${db_path}" "${day}")"
  [[ -f "${db}" ]] || fail "找不到 DB: ${db}"

  sqlite3 "file:${db}?mode=ro" <<SQL
.headers on
.mode column
WITH now_ms AS (
  SELECT CAST(strftime('%s','now') * 1000 AS INTEGER) AS n
)
SELECT
  t.symbol AS symbol,
  COUNT(*) AS rows,
  datetime(MAX(t.ts_ms)/1000,'unixepoch') AS latest_ts_utc,
  ROUND(strftime('%s','now') - MAX(t.ts_ms)/1000.0, 3) AS lag_sec,
  ROUND(
    SUM(CASE WHEN t.ts_ms >= (SELECT n - (${minutes} * 60000) FROM now_ms) THEN 1 ELSE 0 END)
    * 1.0 / ${minutes},
    2
  ) AS growth_per_min_last_${minutes}m
FROM ticks t
GROUP BY t.symbol
ORDER BY symbol;
SQL
}

run_db_symbol() {
  local symbol=""
  local db_path=""
  local day="${DAY_DEFAULT}"
  local last="20"

  [[ $# -ge 1 ]] || fail "缺少 symbol"
  symbol="$1"
  shift

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --db)
        db_path="${2:-}"
        shift 2
        ;;
      --day)
        day="${2:-}"
        shift 2
        ;;
      --last)
        last="${2:-}"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        fail "未知參數: $1"
        ;;
    esac
  done

  require_cmd sqlite3
  local db
  db="$(db_path_from_args "${db_path}" "${day}")"
  [[ -f "${db}" ]] || fail "找不到 DB: ${db}"

  local symbol_sql
  symbol_sql="${symbol//\'/''}"

  sqlite3 "file:${db}?mode=ro" <<SQL
.headers on
.mode column
SELECT
  symbol,
  datetime(ts_ms/1000,'unixepoch') AS ts_utc,
  price,
  volume,
  turnover,
  seq
FROM ticks
WHERE symbol='${symbol_sql}'
ORDER BY ts_ms DESC
LIMIT ${last};
SQL
}

run_export() {
  local db_path=""
  local day="${DAY_DEFAULT}"
  local out=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --db)
        db_path="${2:-}"
        shift 2
        ;;
      --day)
        day="${2:-}"
        shift 2
        ;;
      --out)
        out="${2:-}"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        fail "未知參數: $1"
        ;;
    esac
  done

  require_cmd tar
  local db
  db="$(db_path_from_args "${db_path}" "${day}")"
  [[ -f "${db}" ]] || fail "找不到 DB: ${db}"

  if [[ -z "${out}" ]]; then
    out="/tmp/hk-${day}.tar.gz"
  fi

  local out_dir
  out_dir="$(dirname "${out}")"
  mkdir -p "${out_dir}"

  local base dir
  dir="$(dirname "${db}")"
  base="$(basename "${db}")"

  local files=("${base}")
  [[ -f "${db}-wal" ]] && files+=("${base}-wal")
  [[ -f "${db}-shm" ]] && files+=("${base}-shm")

  tar -C "${dir}" -czf "${out}" "${files[@]}"

  local checksum
  checksum="$(sha256_file "${out}")"
  printf '%s  %s\n' "${checksum}" "$(basename "${out}")" > "${out}.sha256"

  ok "已匯出: ${out}"
  info "sha256: ${checksum}"
  info "校驗檔: ${out}.sha256"
}

run_tg_test() {
  local token="${TG_TOKEN:-${TG_BOT_TOKEN:-}}"
  local chat_id="${TG_CHAT_ID:-}"
  local thread_id="${TG_MESSAGE_THREAD_ID:-}"
  local text=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --token)
        token="${2:-}"
        shift 2
        ;;
      --chat-id)
        chat_id="${2:-}"
        shift 2
        ;;
      --thread-id)
        thread_id="${2:-}"
        shift 2
        ;;
      --text)
        text="${2:-}"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        fail "未知參數: $1"
        ;;
    esac
  done

  [[ -n "${token}" ]] || fail "缺少 TG_TOKEN（可用 env 或 --token）"
  [[ -n "${chat_id}" ]] || fail "缺少 TG_CHAT_ID（可用 env 或 --chat-id）"

  if [[ -z "${text}" ]]; then
    text="✅ HK Tick Collector 測試通知\n結論：Telegram 設定可用\n建議：可開始驗證 health / alert 訊息"
  fi

  require_cmd python3

  TG_TOKEN="${token}" TG_CHAT_ID="${chat_id}" TG_THREAD_ID="${thread_id}" TG_TEXT="${text}" python3 - <<'PY'
import json
import os
import sys
import urllib.parse
import urllib.request

token = os.environ["TG_TOKEN"].strip()
chat_id = os.environ["TG_CHAT_ID"].strip()
thread_id = os.environ.get("TG_THREAD_ID", "").strip()
text = os.environ["TG_TEXT"]

url = f"https://api.telegram.org/bot{token}/sendMessage"
payload = {
    "chat_id": chat_id,
    "text": text,
    "parse_mode": "HTML",
}
if thread_id:
    try:
        payload["message_thread_id"] = int(thread_id)
    except ValueError:
        print("[失敗] thread_id 需為整數", file=sys.stderr)
        raise SystemExit(2)

data = urllib.parse.urlencode(payload).encode("utf-8")
req = urllib.request.Request(url, data=data, method="POST")

try:
    with urllib.request.urlopen(req, timeout=15) as resp:
        body = resp.read().decode("utf-8", errors="replace")
except Exception as exc:  # noqa: BLE001
    print(f"[失敗] Telegram 呼叫失敗: {exc}", file=sys.stderr)
    raise SystemExit(1)

try:
    result = json.loads(body)
except json.JSONDecodeError:
    print("[失敗] Telegram 回傳非 JSON", file=sys.stderr)
    print(body)
    raise SystemExit(1)

if not result.get("ok"):
    print(f"[失敗] Telegram API 回應: {body}", file=sys.stderr)
    raise SystemExit(1)

message_id = result.get("result", {}).get("message_id", "n/a")
print(f"[完成] Telegram 測試訊息已送出 message_id={message_id}")
PY
}

run_doctor() {
  local since="6 hours ago"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --since)
        since="${2:-}"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        fail "未知參數: $1"
        ;;
    esac
  done

  require_cmd systemctl
  require_cmd journalctl
  require_cmd grep

  local active_status
  active_status="$(systemctl is-active "${SERVICE_NAME}" 2>/dev/null || true)"
  [[ -n "${active_status}" ]] || active_status="unknown"

  local logs
  logs="$(journalctl -u "${SERVICE_NAME}" --since "${since}" --no-pager 2>/dev/null || true)"
  local schema_line
  schema_line="$(printf '%s\n' "${logs}" | grep -E "telegram_notifier_started.*notify_schema=" | tail -n 1 || true)"
  local health_enqueue
  health_enqueue="$(printf '%s\n' "${logs}" | grep -E "telegram_enqueue kind=HEALTH " | tail -n 1 || true)"
  local warn_or_alert_enqueue
  warn_or_alert_enqueue="$(printf '%s\n' "${logs}" | grep -E "telegram_enqueue kind=.* severity=(WARN|ALERT)" | tail -n 1 || true)"

  echo "=== HK Tick 版本診斷 ==="
  echo "service=${SERVICE_NAME} status=${active_status} since=${since}"

  if [[ -n "${schema_line}" ]]; then
    echo "[完成] 找到 notify schema 訊息"
    echo "${schema_line}"
  else
    echo "[資訊] 沒找到 notify schema（可能未啟用 TG 或版本較舊）"
  fi

  if [[ -n "${health_enqueue}" ]]; then
    echo "[資訊] 最近 HEALTH enqueue"
    echo "${health_enqueue}"
  fi

  if [[ -n "${warn_or_alert_enqueue}" ]]; then
    echo "[資訊] 最近 WARN/ALERT enqueue"
    echo "${warn_or_alert_enqueue}"
  fi
}

main() {
  [[ $# -ge 1 ]] || { usage; exit 1; }

  case "$1" in
    status)
      shift
      run_status "$@"
      ;;
    logs)
      shift
      run_logs "$@"
      ;;
    doctor)
      shift
      run_doctor "$@"
      ;;
    db)
      shift
      [[ $# -ge 1 ]] || fail "缺少 db 子命令"
      case "$1" in
        stats)
          shift
          run_db_stats "$@"
          ;;
        symbols)
          shift
          run_db_symbols "$@"
          ;;
        symbol)
          shift
          run_db_symbol "$@"
          ;;
        *)
          fail "未知 db 子命令: $1"
          ;;
      esac
      ;;
    export)
      shift
      run_export "$@"
      ;;
    tg)
      shift
      [[ $# -ge 1 ]] || fail "缺少 tg 子命令"
      case "$1" in
        test)
          shift
          run_tg_test "$@"
          ;;
        *)
          fail "未知 tg 子命令: $1"
          ;;
      esac
      ;;
    -h|--help)
      usage
      ;;
    *)
      fail "未知子命令: $1"
      ;;
  esac
}

main "$@"
